/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of tmp. Do not edit this file, edit tmp instead.
 *
 *		ANY CHANGES MADE HERE WILL BE LOST!
 *
 */


#include "features.h"
#ifdef EMBPERL
#include "logger.h"
#include "embperl.h"

#include "client.h"

#ifdef THIS		/* this macro seems to leak out on some systems */
#undef THIS
#endif


XS(XS_Client_IsClient); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsClient)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsClient(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsClient();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_Disconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Disconnect)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::Disconnect(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->Disconnect();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_Message); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Message)
{
	dXSARGS;
	if (items < 3)
		Perl_croak(aTHX_ "Usage: Client::Message(THIS, Type, pMessage, ...)");
	{
		Client *		THIS;
		MessageFormat		Type = (MessageFormat)SvUV(ST(1));
		char*		pMessage = (char *)SvPV_nolen(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->Message(Type, pMessage);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_AddToCursorBag); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_AddToCursorBag)
{
	dXSARGS;
	if (items < 3 || items > 4)
		Perl_croak(aTHX_ "Usage: Client::AddToCursorBag(THIS, item, slot, charges= 1)");
	{
		Client *		THIS;
		int16		item = (int16)SvUV(ST(1));
		int16		slot = (int16)SvUV(ST(2));
		int8		charges;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 4)
			charges = 1;
		else {
			charges = (int8)SvUV(ST(3));
		}

		THIS->AddToCursorBag(item, slot, charges);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetIP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetIP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetIP(THIS)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetIP();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetPort); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPort)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPort(THIS)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPort();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_Save); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Save)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::Save(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->Save();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_Connected); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Connected)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::Connected(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->Connected();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_Kick); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Kick)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::Kick(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->Kick();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetAnon); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetAnon)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetAnon(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetAnon();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_Attack); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Attack)
{
	dXSARGS;
	if (items < 2 || items > 5)
		Perl_croak(aTHX_ "Usage: Client::Attack(THIS, other, hand= 13, procEligible= true, riposte= false)");
	{
		Client *		THIS;
		Mob*		other;
		int		hand;
		bool		procEligible;
		bool		riposte;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (sv_derived_from(ST(1), "Mob")) {
			IV tmp = SvIV((SV*)SvRV(ST(1)));
			other = INT2PTR(Mob *,tmp);
		}
		else
			Perl_croak(aTHX_ "other is not of type Mob");
		if(other == NULL)
			Perl_croak(aTHX_ "other is NULL, avoiding crash.");

		if (items < 3)
			hand = 13;
		else {
			hand = (int)SvIV(ST(2));
		}

		if (items < 4)
			procEligible = true;
		else {
			procEligible = (bool)SvTRUE(ST(3));
		}

		if (items < 5)
			riposte = false;
		else {
			riposte = (bool)SvTRUE(ST(4));
		}

		THIS->Attack(other, hand, procEligible, riposte);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_Heal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Heal)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::Heal(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->Heal();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_Damage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Damage)
{
	dXSARGS;
	if (items < 4 || items > 5)
		Perl_croak(aTHX_ "Usage: Client::Damage(THIS, other, damage, spell_id, attack_skill= 0x04)");
	{
		Client *		THIS;
		Mob*		other;
		sint32		damage = (sint32)SvIV(ST(2));
		int16		spell_id = (int16)SvUV(ST(3));
		int8		attack_skill;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (sv_derived_from(ST(1), "Mob")) {
			IV tmp = SvIV((SV*)SvRV(ST(1)));
			other = INT2PTR(Mob *,tmp);
		}
		else
			Perl_croak(aTHX_ "other is not of type Mob");
		if(other == NULL)
			Perl_croak(aTHX_ "other is NULL, avoiding crash.");

		if (items < 5)
			attack_skill = 0x04;
		else {
			attack_skill = (int8)SvUV(ST(4));
		}

		THIS->Damage(other, damage, spell_id, attack_skill);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_Death); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Death)
{
	dXSARGS;
	if (items < 3 || items > 5)
		Perl_croak(aTHX_ "Usage: Client::Death(THIS, other, damage, spell_id= 0xFFFF, attack_skill= 0x04)");
	{
		Client *		THIS;
		Mob*		other;
		sint32		damage = (sint32)SvIV(ST(2));
		int16		spell_id;
		int8		attack_skill;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (sv_derived_from(ST(1), "Mob")) {
			IV tmp = SvIV((SV*)SvRV(ST(1)));
			other = INT2PTR(Mob *,tmp);
		}
		else
			Perl_croak(aTHX_ "other is not of type Mob");
		if(other == NULL)
			Perl_croak(aTHX_ "other is NULL, avoiding crash.");

		if (items < 4)
			spell_id = 0xFFFF;
		else {
			spell_id = (int16)SvUV(ST(3));
		}

		if (items < 5)
			attack_skill = 0x04;
		else {
			attack_skill = (int8)SvUV(ST(4));
		}

		THIS->Death(other, damage, spell_id, attack_skill);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_MakeCorpse); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_MakeCorpse)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::MakeCorpse(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->MakeCorpse();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetMana); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetMana)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetMana(THIS, amount)");
	{
		Client *		THIS;
		sint32		RETVAL;
		dXSTARG;
		sint32		amount = (sint32)SvIV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->SetMana(amount);
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_Duck); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Duck)
{
	dXSARGS;
	if (items < 1 || items > 2)
		Perl_croak(aTHX_ "Usage: Client::Duck(THIS, send_update_packet= true)");
	{
		Client *		THIS;
		bool		send_update_packet;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 2)
			send_update_packet = true;
		else {
			send_update_packet = (bool)SvTRUE(ST(1));
		}

		THIS->Duck(send_update_packet);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_Sit); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Sit)
{
	dXSARGS;
	if (items < 1 || items > 2)
		Perl_croak(aTHX_ "Usage: Client::Sit(THIS, send_update_packet= true)");
	{
		Client *		THIS;
		bool		send_update_packet;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 2)
			send_update_packet = true;
		else {
			send_update_packet = (bool)SvTRUE(ST(1));
		}

		THIS->Sit(send_update_packet);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_Stand); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Stand)
{
	dXSARGS;
	if (items < 1 || items > 2)
		Perl_croak(aTHX_ "Usage: Client::Stand(THIS, send_update_packet= true)");
	{
		Client *		THIS;
		bool		send_update_packet;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 2)
			send_update_packet = true;
		else {
			send_update_packet = (bool)SvTRUE(ST(1));
		}

		THIS->Stand(send_update_packet);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetMaxHP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetMaxHP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::SetMaxHP(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetMaxHP();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetGM); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetGM)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetGM(THIS, toggle)");
	{
		Client *		THIS;
		bool		toggle = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetGM(toggle);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetBaseRace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseRace)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseRace(THIS)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseRace();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseGender); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseGender)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseGender(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseGender();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseSTR); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseSTR)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseSTR(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseSTR();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseSTA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseSTA)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseSTA(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseSTA();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseCHA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseCHA)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseCHA(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseCHA();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseDEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseDEX)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseDEX(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseDEX();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseINT); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseINT)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseINT(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseINT();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseAGI); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseAGI)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseAGI(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseAGI();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseWIS); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseWIS)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseWIS(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseWIS();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetLanguageSkill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetLanguageSkill)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::GetLanguageSkill(THIS, n)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;
		int8		n = (int8)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetLanguageSkill(n);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetLanguageSkill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetLanguageSkill)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::SetLanguageSkill(THIS, languageid, value)");
	{
		Client *		THIS;
		int		languageid = (int)SvIV(ST(1));
		int8		value = (int8)SvUV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetLanguageSkill(languageid, value);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetSTR); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetSTR)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetSTR(THIS)");
	{
		Client *		THIS;
		sint16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetSTR();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetSTA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetSTA)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetSTA(THIS)");
	{
		Client *		THIS;
		sint16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetSTA();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetDEX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetDEX)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetDEX(THIS)");
	{
		Client *		THIS;
		sint16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetDEX();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetAGI); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetAGI)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetAGI(THIS)");
	{
		Client *		THIS;
		sint16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetAGI();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetINT); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetINT)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetINT(THIS)");
	{
		Client *		THIS;
		sint16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetINT();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetWIS); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetWIS)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetWIS(THIS)");
	{
		Client *		THIS;
		sint16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetWIS();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetCHA); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetCHA)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetCHA(THIS)");
	{
		Client *		THIS;
		sint16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetCHA();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetEXP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetEXP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetEXP(THIS)");
	{
		Client *		THIS;
		uint32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetEXP();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetHP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetHP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetHP(THIS)");
	{
		Client *		THIS;
		sint32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetHP();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetMaxHP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetMaxHP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetMaxHP(THIS)");
	{
		Client *		THIS;
		sint32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetMaxHP();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetBaseHP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetBaseHP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetBaseHP(THIS)");
	{
		Client *		THIS;
		sint32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetBaseHP();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_CalcMaxHP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_CalcMaxHP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::CalcMaxHP(THIS)");
	{
		Client *		THIS;
		sint32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->CalcMaxHP();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_CalcBaseHP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_CalcBaseHP)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::CalcBaseHP(THIS)");
	{
		Client *		THIS;
		sint32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->CalcBaseHP();
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetTotalLevelExp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetTotalLevelExp)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetTotalLevelExp(THIS)");
	{
		Client *		THIS;
		uint32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetTotalLevelExp();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_AddEXP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_AddEXP)
{
	dXSARGS;
	if (items < 2 || items > 3)
		Perl_croak(aTHX_ "Usage: Client::AddEXP(THIS, add_exp, resurrected= false)");
	{
		Client *		THIS;
		uint32		add_exp = (uint32)SvUV(ST(1));
		bool		resurrected;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 3)
			resurrected = false;
		else {
			resurrected = (bool)SvTRUE(ST(2));
		}

		THIS->AddEXP(add_exp, resurrected);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetEXP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetEXP)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetEXP(THIS, set_exp)");
	{
		Client *		THIS;
		uint32		set_exp = (uint32)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetEXP(set_exp);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetLevel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetLevel)
{
	dXSARGS;
	if (items < 2 || items > 3)
		Perl_croak(aTHX_ "Usage: Client::SetLevel(THIS, set_level, show_message= true)");
	{
		Client *		THIS;
		uint8		set_level = (uint8)SvUV(ST(1));
		bool		show_message;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 3)
			show_message = true;
		else {
			show_message = (bool)SvTRUE(ST(2));
		}

		THIS->SetLevel(set_level, show_message);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GoToBind); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GoToBind)
{
	dXSARGS;
	if (items < 1 || items > 2)
		Perl_croak(aTHX_ "Usage: Client::GoToBind(THIS, death= false)");
	{
		Client *		THIS;
		bool		death;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 2)
			death = false;
		else {
			death = (bool)SvTRUE(ST(1));
		}

		THIS->GoToBind(death);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetBindPoint); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetBindPoint)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::SetBindPoint(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetBindPoint();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_MovePC); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_MovePC)
{
	dXSARGS;
	if (items < 5 || items > 7)
		Perl_croak(aTHX_ "Usage: Client::MovePC(THIS, zonename, x, y, z, ignorerestrictions= false, useSummonMessage= true)");
	{
		Client *		THIS;
		char*		zonename = (char *)SvPV_nolen(ST(1));
		float		x = (float)SvNV(ST(2));
		float		y = (float)SvNV(ST(3));
		float		z = (float)SvNV(ST(4));
		bool		ignorerestrictions;
		bool		useSummonMessage;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 6)
			ignorerestrictions = false;
		else {
			ignorerestrictions = (bool)SvTRUE(ST(5));
		}

		if (items < 7)
			useSummonMessage = true;
		else {
			useSummonMessage = (bool)SvTRUE(ST(6));
		}

		THIS->MovePC(zonename, x, y, z, ignorerestrictions, useSummonMessage);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_ZonePC); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_ZonePC)
{
	dXSARGS;
	if (items != 5)
		Perl_croak(aTHX_ "Usage: Client::ZonePC(THIS, zonename, x, y, z)");
	{
		Client *		THIS;
		char*		zonename = (char *)SvPV_nolen(ST(1));
		float		x = (float)SvNV(ST(2));
		float		y = (float)SvNV(ST(3));
		float		z = (float)SvNV(ST(4));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->ZonePC(zonename, x, y, z);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_TeleportPC); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_TeleportPC)
{
	dXSARGS;
	if (items < 5 || items > 6)
		Perl_croak(aTHX_ "Usage: Client::TeleportPC(THIS, zonename, x, y, z, heading= 0)");
	{
		Client *		THIS;
		char*		zonename = (char *)SvPV_nolen(ST(1));
		float		x = (float)SvNV(ST(2));
		float		y = (float)SvNV(ST(3));
		float		z = (float)SvNV(ST(4));
		float		heading;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 6)
			heading = 0;
		else {
			heading = (float)SvNV(ST(5));
		}

		THIS->TeleportPC(zonename, x, y, z, heading);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_TranslocatePC); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_TranslocatePC)
{
	dXSARGS;
	if (items != 5)
		Perl_croak(aTHX_ "Usage: Client::TranslocatePC(THIS, zonename, x, y, z)");
	{
		Client *		THIS;
		char*		zonename = (char *)SvPV_nolen(ST(1));
		float		x = (float)SvNV(ST(2));
		float		y = (float)SvNV(ST(3));
		float		z = (float)SvNV(ST(4));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->TranslocatePC(zonename, x, y, z);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SummonItem); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SummonItem)
{
	dXSARGS;
	if (items < 2 || items > 3)
		Perl_croak(aTHX_ "Usage: Client::SummonItem(THIS, item_id, charges= 1)");
	{
		Client *		THIS;
		bool		RETVAL;
		int16		item_id = (int16)SvUV(ST(1));
		sint8		charges;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 3)
			charges = 1;
		else {
			charges = (sint8)SvIV(ST(2));
		}

		RETVAL = THIS->SummonItem(item_id, charges);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SummonItemNonBlob); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SummonItemNonBlob)
{
	dXSARGS;
	if (items < 2 || items > 3)
		Perl_croak(aTHX_ "Usage: Client::SummonItemNonBlob(THIS, item_id, charges= 0)");
	{
		Client *		THIS;
		bool		RETVAL;
		int16		item_id = (int16)SvUV(ST(1));
		sint8		charges;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 3)
			charges = 0;
		else {
			charges = (sint8)SvIV(ST(2));
		}

		RETVAL = THIS->SummonItemNonBlob(item_id, charges);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_ChangeSurname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_ChangeSurname)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::ChangeSurname(THIS, in_Surname)");
	{
		Client *		THIS;
		char*		in_Surname = (char *)SvPV_nolen(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->ChangeSurname(in_Surname);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetFactionLevel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetFactionLevel)
{
	dXSARGS;
	if (items != 6)
		Perl_croak(aTHX_ "Usage: Client::SetFactionLevel(THIS, char_id, npc_id, char_class, char_race, char_deity)");
	{
		Client *		THIS;
		int32		char_id = (int32)SvUV(ST(1));
		int32		npc_id = (int32)SvUV(ST(2));
		int8		char_class = (int8)SvUV(ST(3));
		int8		char_race = (int8)SvUV(ST(4));
		int8		char_deity = (int8)SvUV(ST(5));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetFactionLevel(char_id, npc_id, char_class, char_race, char_deity);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetFactionLevel2); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetFactionLevel2)
{
	dXSARGS;
	if (items != 7)
		Perl_croak(aTHX_ "Usage: Client::SetFactionLevel2(THIS, char_id, faction_id, char_class, char_race, char_deity, value)");
	{
		Client *		THIS;
		int32		char_id = (int32)SvUV(ST(1));
		sint32		faction_id = (sint32)SvIV(ST(2));
		int8		char_class = (int8)SvUV(ST(3));
		int8		char_race = (int8)SvUV(ST(4));
		int8		char_deity = (int8)SvUV(ST(5));
		sint32		value = (sint32)SvIV(ST(6));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetFactionLevel2(char_id, faction_id, char_class, char_race, char_deity, value);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetSkill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetSkill)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::GetSkill(THIS, skillid)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;
		int		skillid = (int)SvIV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetSkill(skillid);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetSkill); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetSkill)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::SetSkill(THIS, skillid, value)");
	{
		Client *		THIS;
		int		skillid = (int)SvIV(ST(1));
		int8		value = (int8)SvUV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetSkill(skillid, value);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_CharacterID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_CharacterID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::CharacterID(THIS)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->CharacterID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_AccountID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_AccountID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::AccountID(THIS)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->AccountID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_AccountName); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_AccountName)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::AccountName(THIS)");
	{
		Client *		THIS;
		char *		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->AccountName();
		sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
	}
	XSRETURN(1);
}


XS(XS_Client_Admin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_Admin)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::Admin(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->Admin();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_UpdateAdmin); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_UpdateAdmin)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::UpdateAdmin(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->UpdateAdmin();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_UpdateWho); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_UpdateWho)
{
	dXSARGS;
	if (items < 1 || items > 2)
		Perl_croak(aTHX_ "Usage: Client::UpdateWho(THIS, remove= false)");
	{
		Client *		THIS;
		bool		remove;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 2)
			remove = false;
		else {
			remove = (bool)SvTRUE(ST(1));
		}

		THIS->UpdateWho(remove);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GMHideMe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GMHideMe)
{
	dXSARGS;
	if (items < 1 || items > 2)
		Perl_croak(aTHX_ "Usage: Client::GMHideMe(THIS, client= 0)");
	{
		Client *		THIS;
		bool		RETVAL;
		Client*		client;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 2)
			client = 0;
		else {
			if (sv_derived_from(ST(1), "Client")) {
				IV tmp = SvIV((SV*)SvRV(ST(1)));
				client = INT2PTR(Client *,tmp);
			}
			else
				Perl_croak(aTHX_ "client is not of type Client");
			if(client == NULL)
				Perl_croak(aTHX_ "client is NULL, avoiding crash.");
		}

		RETVAL = THIS->GMHideMe(client);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GuildEQID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GuildEQID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GuildEQID(THIS)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GuildEQID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GuildDBID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GuildDBID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GuildDBID(THIS)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GuildDBID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GuildRank); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GuildRank)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GuildRank(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GuildRank();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetGuild); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetGuild)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::SetGuild(THIS, in_guilddbid, in_rank)");
	{
		Client *		THIS;
		bool		RETVAL;
		int32		in_guilddbid = (int32)SvUV(ST(1));
		int8		in_rank = (int8)SvUV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->SetGuild(in_guilddbid, in_rank);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SendManaUpdatePacket); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SendManaUpdatePacket)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::SendManaUpdatePacket(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SendManaUpdatePacket();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetFace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetFace)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetFace(THIS)");
	{
		Client *		THIS;
		int8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetFace();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetItemAt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetItemAt)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::GetItemAt(THIS, in_slot)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;
		int16		in_slot = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetItemAt(in_slot);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_PutItemInInventory); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_PutItemInInventory)
{
	dXSARGS;
	if (items != 4)
		Perl_croak(aTHX_ "Usage: Client::PutItemInInventory(THIS, slotid, itemid, charges)");
	{
		Client *		THIS;
		bool		RETVAL;
		int16		slotid = (int16)SvUV(ST(1));
		int16		itemid = (int16)SvUV(ST(2));
		sint8		charges = (sint8)SvIV(ST(3));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->PutItemInInventory(slotid, itemid, charges);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_DeleteItemInInventory); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_DeleteItemInInventory)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::DeleteItemInInventory(THIS, slotid)");
	{
		Client *		THIS;
		uint32		slotid = (uint32)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->DeleteItemInInventory(slotid);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SendClientMoneyUpdate); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SendClientMoneyUpdate)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::SendClientMoneyUpdate(THIS, type, amount)");
	{
		Client *		THIS;
		int8		type = (int8)SvUV(ST(1));
		int32		amount = (int32)SvUV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SendClientMoneyUpdate(type, amount);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_TakeMoneyFromPP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_TakeMoneyFromPP)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::TakeMoneyFromPP(THIS, copper)");
	{
		Client *		THIS;
		bool		RETVAL;
		uint32		copper = (uint32)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->TakeMoneyFromPP(copper);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_AddMoneyToPP); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_AddMoneyToPP)
{
	dXSARGS;
	if (items != 6)
		Perl_croak(aTHX_ "Usage: Client::AddMoneyToPP(THIS, copper, silver, gold, platinum, updateclient)");
	{
		Client *		THIS;
		uint32		copper = (uint32)SvUV(ST(1));
		uint32		silver = (uint32)SvUV(ST(2));
		uint32		gold = (uint32)SvUV(ST(3));
		uint32		platinum = (uint32)SvUV(ST(4));
		bool		updateclient = (bool)SvTRUE(ST(5));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->AddMoneyToPP(copper, silver, gold, platinum, updateclient);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SendClientQuestCompletedFanfare); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SendClientQuestCompletedFanfare)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::SendClientQuestCompletedFanfare(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SendClientQuestCompletedFanfare();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SendClientQuestCompletedMoney); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SendClientQuestCompletedMoney)
{
	dXSARGS;
	if (items != 6)
		Perl_croak(aTHX_ "Usage: Client::SendClientQuestCompletedMoney(THIS, sender, copper, silver, gold, platinum)");
	{
		Client *		THIS;
		Mob*		sender;
		uint32		copper = (uint32)SvUV(ST(2));
		uint32		silver = (uint32)SvUV(ST(3));
		uint32		gold = (uint32)SvUV(ST(4));
		uint32		platinum = (uint32)SvUV(ST(5));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (sv_derived_from(ST(1), "Mob")) {
			IV tmp = SvIV((SV*)SvRV(ST(1)));
			sender = INT2PTR(Mob *,tmp);
		}
		else
			Perl_croak(aTHX_ "sender is not of type Mob");
		if(sender == NULL)
			Perl_croak(aTHX_ "sender is NULL, avoiding crash.");

		THIS->SendClientQuestCompletedMoney(sender, copper, silver, gold, platinum);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_IsGrouped); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsGrouped)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsGrouped(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsGrouped();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GroupInvitePending); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GroupInvitePending)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GroupInvitePending(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GroupInvitePending();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetGroupInvitePending); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetGroupInvitePending)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetGroupInvitePending(THIS, status)");
	{
		Client *		THIS;
		bool		status = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetGroupInvitePending(status);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_ProcessChangeLeader); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_ProcessChangeLeader)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::ProcessChangeLeader(THIS, member)");
	{
		Client *		THIS;
		char*		member = (char *)SvPV_nolen(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->ProcessChangeLeader(member);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_RefreshGroup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_RefreshGroup)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::RefreshGroup(THIS, groupid, action)");
	{
		Client *		THIS;
		int32		groupid = (int32)SvUV(ST(1));
		int8		action = (int8)SvUV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->RefreshGroup(groupid, action);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_IsMedding); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsMedding)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsMedding(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsMedding();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GetDuelTarget); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetDuelTarget)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetDuelTarget(THIS)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetDuelTarget();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_IsDueling); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsDueling)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsDueling(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsDueling();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetDuelTarget); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetDuelTarget)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetDuelTarget(THIS, set_id)");
	{
		Client *		THIS;
		int16		set_id = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetDuelTarget(set_id);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetDueling); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetDueling)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetDueling(THIS, duel)");
	{
		Client *		THIS;
		bool		duel = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetDueling(duel);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetFeigned); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetFeigned)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetFeigned(THIS, in_feigned)");
	{
		Client *		THIS;
		bool		in_feigned = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetFeigned(in_feigned);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetFeigned); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetFeigned)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetFeigned(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetFeigned();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetHide); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetHide)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetHide(THIS, bHidden)");
	{
		Client *		THIS;
		bool		bHidden = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetHide(bHidden);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetHide); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetHide)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetHide(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetHide();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetSneaking); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetSneaking)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetSneaking(THIS, bSneaking)");
	{
		Client *		THIS;
		bool		bSneaking = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetSneaking(bSneaking);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetSneaking); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetSneaking)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetSneaking(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetSneaking();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GetFactionLevel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetFactionLevel)
{
	dXSARGS;
	if (items != 8)
		Perl_croak(aTHX_ "Usage: Client::GetFactionLevel(THIS, char_id, npc_id, p_race, p_class, p_deity, pFaction, tnpc)");
	{
		Client *		THIS;
		FACTION_VALUE		RETVAL;
		dXSTARG;
		int32		char_id = (int32)SvUV(ST(1));
		int32		npc_id = (int32)SvUV(ST(2));
		int32		p_race = (int32)SvUV(ST(3));
		int32		p_class = (int32)SvUV(ST(4));
		int32		p_deity = (int32)SvUV(ST(5));
		sint32		pFaction = (sint32)SvIV(ST(6));
		Mob*		tnpc;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (sv_derived_from(ST(7), "Mob")) {
			IV tmp = SvIV((SV*)SvRV(ST(7)));
			tnpc = INT2PTR(Mob *,tmp);
		}
		else
			Perl_croak(aTHX_ "tnpc is not of type Mob");
		if(tnpc == NULL)
			Perl_croak(aTHX_ "tnpc is NULL, avoiding crash.");

		RETVAL = THIS->GetFactionLevel(char_id, npc_id, p_race, p_class, p_deity, pFaction, tnpc);
		XSprePUSH; PUSHi((IV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetWornInstrumentType); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetWornInstrumentType)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetWornInstrumentType(THIS)");
	{
		Client *		THIS;
		uint8		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetWornInstrumentType();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_GetInstrumentModByType); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetInstrumentModByType)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::GetInstrumentModByType(THIS, instruType)");
	{
		Client *		THIS;
		uint8		RETVAL;
		dXSTARG;
		uint8		instruType = (uint8)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetInstrumentModByType(instruType);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetInstrumentModByType); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetInstrumentModByType)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::SetInstrumentModByType(THIS, instruType, mod)");
	{
		Client *		THIS;
		uint8		instruType = (uint8)SvUV(ST(1));
		uint8		mod = (uint8)SvUV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetInstrumentModByType(instruType, mod);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_ResetAllInstrumentMod); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_ResetAllInstrumentMod)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::ResetAllInstrumentMod(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->ResetAllInstrumentMod();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_UpdateInstrumentMod); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_UpdateInstrumentMod)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::UpdateInstrumentMod(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->UpdateInstrumentMod();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_HasRequiredInstrument); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_HasRequiredInstrument)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::HasRequiredInstrument(THIS, spell_id)");
	{
		Client *		THIS;
		bool		RETVAL;
		int16		spell_id = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->HasRequiredInstrument(spell_id);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_CheckLoreConflict); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_CheckLoreConflict)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::CheckLoreConflict(THIS, itemid)");
	{
		Client *		THIS;
		bool		RETVAL;
		int16		itemid = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->CheckLoreConflict(itemid);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SendStationItem); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SendStationItem)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SendStationItem(THIS, oldPlayerID)");
	{
		Client *		THIS;
		int32		oldPlayerID = (int32)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SendStationItem(oldPlayerID);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_FindItemInInventory); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_FindItemInInventory)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::FindItemInInventory(THIS, itemid)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;
		int16		itemid = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->FindItemInInventory(itemid);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_FindItemTypeInInventory); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_FindItemTypeInInventory)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::FindItemTypeInInventory(THIS, itemtype)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;
		int16		itemtype = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->FindItemTypeInInventory(itemtype);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_CreateZoneLineNode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_CreateZoneLineNode)
{
	dXSARGS;
	if (items != 4)
		Perl_croak(aTHX_ "Usage: Client::CreateZoneLineNode(THIS, zoneName, connectingZoneName, range)");
	{
		Client *		THIS;
		char*		zoneName = (char *)SvPV_nolen(ST(1));
		char*		connectingZoneName = (char *)SvPV_nolen(ST(2));
		int16		range = (int16)SvUV(ST(3));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->CreateZoneLineNode(zoneName, connectingZoneName, range);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_ScanForZoneLines); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_ScanForZoneLines)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::ScanForZoneLines(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->ScanForZoneLines();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_FearMovement); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_FearMovement)
{
	dXSARGS;
	if (items != 4)
		Perl_croak(aTHX_ "Usage: Client::FearMovement(THIS, x, y, z)");
	{
		Client *		THIS;
		bool		RETVAL;
		float		x = (float)SvNV(ST(1));
		float		y = (float)SvNV(ST(2));
		float		z = (float)SvNV(ST(3));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->FearMovement(x, y, z);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GetAccountName); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetAccountName)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetAccountName(THIS)");
	{
		Client *		THIS;
		char *		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetAccountName();
		sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
	}
	XSRETURN(1);
}


XS(XS_Client_GetAccountID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetAccountID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetAccountID(THIS)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetAccountID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_IsStunned); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsStunned)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsStunned(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsStunned();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GetDebugMe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetDebugMe)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetDebugMe(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetDebugMe();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetDebugMe); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetDebugMe)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetDebugMe(THIS, choice)");
	{
		Client *		THIS;
		bool		choice = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetDebugMe(choice);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetMyEyeOfZommID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetMyEyeOfZommID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetMyEyeOfZommID(THIS)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetMyEyeOfZommID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetMyEyeOfZomm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetMyEyeOfZomm)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetMyEyeOfZomm(THIS, npc)");
	{
		Client *		THIS;
		NPC*		npc;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (sv_derived_from(ST(1), "NPC")) {
			IV tmp = SvIV((SV*)SvRV(ST(1)));
			npc = INT2PTR(NPC *,tmp);
		}
		else
			Perl_croak(aTHX_ "npc is not of type NPC");
		if(npc == NULL)
			Perl_croak(aTHX_ "npc is NULL, avoiding crash.");

		THIS->SetMyEyeOfZomm(npc);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_FeignDeath); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_FeignDeath)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::FeignDeath(THIS, skillValue)");
	{
		Client *		THIS;
		int16		skillValue = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->FeignDeath(skillValue);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetDeathSave); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetDeathSave)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetDeathSave(THIS)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetDeathSave();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetDeathSave); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetDeathSave)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetDeathSave(THIS, SuccessChance)");
	{
		Client *		THIS;
		int16		SuccessChance = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetDeathSave(SuccessChance);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetFeared); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetFeared)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetFeared(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetFeared();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetFeared); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetFeared)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetFeared(THIS, in)");
	{
		Client *		THIS;
		bool		in = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetFeared(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetFearDestination); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetFearDestination)
{
	dXSARGS;
	if (items != 4)
		Perl_croak(aTHX_ "Usage: Client::GetFearDestination(THIS, x, y, z)");
	{
		Client *		THIS;
		bool		RETVAL;
		float		x = (float)SvNV(ST(1));
		float		y = (float)SvNV(ST(2));
		float		z = (float)SvNV(ST(3));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetFearDestination(x, y, z);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GetCharmDestination); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetCharmDestination)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::GetCharmDestination(THIS, x, y)");
	{
		Client *		THIS;
		bool		RETVAL;
		float		x = (float)SvNV(ST(1));
		float		y = (float)SvNV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetCharmDestination(x, y);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_UpdateCharmPosition); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_UpdateCharmPosition)
{
	dXSARGS;
	if (items != 4)
		Perl_croak(aTHX_ "Usage: Client::UpdateCharmPosition(THIS, targetX, targetY, meleeReach)");
	{
		Client *		THIS;
		float		targetX = (float)SvNV(ST(1));
		float		targetY = (float)SvNV(ST(2));
		int16		meleeReach = (int16)SvUV(ST(3));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->UpdateCharmPosition(targetX, targetY, meleeReach);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_fdistance); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_fdistance)
{
	dXSARGS;
	if (items != 5)
		Perl_croak(aTHX_ "Usage: Client::fdistance(THIS, x1, y1, x2, y2)");
	{
		Client *		THIS;
		float		RETVAL;
		dXSTARG;
		float		x1 = (float)SvNV(ST(1));
		float		y1 = (float)SvNV(ST(2));
		float		x2 = (float)SvNV(ST(3));
		float		y2 = (float)SvNV(ST(4));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->fdistance(x1, y1, x2, y2);
		XSprePUSH; PUSHn((double)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_square); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_square)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::square(THIS, number)");
	{
		Client *		THIS;
		float		RETVAL;
		dXSTARG;
		float		number = (float)SvNV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->square(number);
		XSprePUSH; PUSHn((double)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetCharmed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetCharmed)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetCharmed(THIS, in)");
	{
		Client *		THIS;
		bool		in = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetCharmed(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_IsCharmed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsCharmed)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsCharmed(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsCharmed();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetBerserk); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetBerserk)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetBerserk(THIS, in)");
	{
		Client *		THIS;
		bool		in = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetBerserk(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_IsBerserk); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsBerserk)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsBerserk(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsBerserk();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_CanFish); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_CanFish)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::CanFish(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->CanFish();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GoFish); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GoFish)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GoFish(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->GoFish();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SendCharmPermissions); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SendCharmPermissions)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::SendCharmPermissions(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SendCharmPermissions();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_IsInWater); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsInWater)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsInWater(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsInWater();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_IsInLava); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsInLava)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsInLava(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsInLava();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_DoInstillDoubt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_DoInstillDoubt)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::DoInstillDoubt(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->DoInstillDoubt();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_BindWound); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_BindWound)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::BindWound(THIS, bindwound_target, fail)");
	{
		Client *		THIS;
		bool		RETVAL;
		Mob*		bindwound_target;
		bool		fail = (bool)SvTRUE(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (sv_derived_from(ST(1), "Mob")) {
			IV tmp = SvIV((SV*)SvRV(ST(1)));
			bindwound_target = INT2PTR(Mob *,tmp);
		}
		else
			Perl_croak(aTHX_ "bindwound_target is not of type Mob");
		if(bindwound_target == NULL)
			Perl_croak(aTHX_ "bindwound_target is NULL, avoiding crash.");

		RETVAL = THIS->BindWound(bindwound_target, fail);
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetIsZoning); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetIsZoning)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetIsZoning(THIS, in)");
	{
		Client *		THIS;
		bool		in = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetIsZoning(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetZoningX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetZoningX)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetZoningX(THIS, in)");
	{
		Client *		THIS;
		float		in = (float)SvNV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetZoningX(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetZoningY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetZoningY)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetZoningY(THIS, in)");
	{
		Client *		THIS;
		float		in = (float)SvNV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetZoningY(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetZoningZ); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetZoningZ)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetZoningZ(THIS, in)");
	{
		Client *		THIS;
		float		in = (float)SvNV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetZoningZ(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetZoningHeading); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetZoningHeading)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetZoningHeading(THIS, in)");
	{
		Client *		THIS;
		int8		in = (int8)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetZoningHeading(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetUsingSoftCodedZoneLine); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetUsingSoftCodedZoneLine)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetUsingSoftCodedZoneLine(THIS, in)");
	{
		Client *		THIS;
		bool		in = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetUsingSoftCodedZoneLine(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetTempHeading); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetTempHeading)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetTempHeading(THIS, in)");
	{
		Client *		THIS;
		int8		in = (int8)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetTempHeading(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetVoiceGrafting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetVoiceGrafting)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetVoiceGrafting(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetVoiceGrafting();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetVoiceGrafting); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetVoiceGrafting)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetVoiceGrafting(THIS, in)");
	{
		Client *		THIS;
		bool		in = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetVoiceGrafting(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_SetPendingRezExp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingRezExp)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingRezExp(THIS, in)");
	{
		Client *		THIS;
		int32		in = (int32)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingRezExp(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingRezExp); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingRezExp)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingRezExp(THIS)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingRezExp();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetPendingRez); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingRez)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingRez(THIS, in)");
	{
		Client *		THIS;
		bool		in = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingRez(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingRez); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingRez)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingRez(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingRez();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetPendingCorpseID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingCorpseID)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingCorpseID(THIS, in)");
	{
		Client *		THIS;
		int32		in = (int32)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingCorpseID(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingCorpseID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingCorpseID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingCorpseID(THIS)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingCorpseID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetPendingRezX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingRezX)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingRezX(THIS, in)");
	{
		Client *		THIS;
		float		in = (float)SvNV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingRezX(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingRezX); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingRezX)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingRezX(THIS)");
	{
		Client *		THIS;
		float		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingRezX();
		XSprePUSH; PUSHn((double)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetPendingRezY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingRezY)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingRezY(THIS, in)");
	{
		Client *		THIS;
		float		in = (float)SvNV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingRezY(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingRezY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingRezY)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingRezY(THIS)");
	{
		Client *		THIS;
		float		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingRezY();
		XSprePUSH; PUSHn((double)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetPendingRezZ); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingRezZ)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingRezZ(THIS, in)");
	{
		Client *		THIS;
		float		in = (float)SvNV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingRezZ(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingRezZ); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingRezZ)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingRezZ(THIS)");
	{
		Client *		THIS;
		float		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingRezZ();
		XSprePUSH; PUSHn((double)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetPendingRezZone); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingRezZone)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingRezZone(THIS, in)");
	{
		Client *		THIS;
		char*		in = (char *)SvPV_nolen(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingRezZone(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingRezZone); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingRezZone)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingRezZone(THIS)");
	{
		Client *		THIS;
		char *		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingRezZone();
		sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
	}
	XSRETURN(1);
}


XS(XS_Client_SetPendingSpellID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetPendingSpellID)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetPendingSpellID(THIS, in)");
	{
		Client *		THIS;
		int16		in = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetPendingSpellID(in);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetPendingSpellID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetPendingSpellID)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetPendingSpellID(THIS)");
	{
		Client *		THIS;
		int16		RETVAL;
		dXSTARG;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetPendingSpellID();
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_StartPendingRezTimer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_StartPendingRezTimer)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::StartPendingRezTimer(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->StartPendingRezTimer();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_StopPendingRezTimer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_StopPendingRezTimer)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::StopPendingRezTimer(THIS)");
	{
		Client *		THIS;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->StopPendingRezTimer();
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetRelativeCoordToBoat); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetRelativeCoordToBoat)
{
	dXSARGS;
	if (items != 6)
		Perl_croak(aTHX_ "Usage: Client::GetRelativeCoordToBoat(THIS, x, y, angle, xout, yout)");
	{
		Client *		THIS;
		float		x = (float)SvNV(ST(1));
		float		y = (float)SvNV(ST(2));
		float		angle = (float)SvNV(ST(3));
		float		xout = (float)SvNV(ST(4));
		float		yout = (float)SvNV(ST(5));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->GetRelativeCoordToBoat(x, y, angle, xout, yout);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_IsAlive); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_IsAlive)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::IsAlive(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->IsAlive();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_GetSpellImmunity); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetSpellImmunity)
{
	dXSARGS;
	if (items != 1)
		Perl_croak(aTHX_ "Usage: Client::GetSpellImmunity(THIS)");
	{
		Client *		THIS;
		bool		RETVAL;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetSpellImmunity();
		ST(0) = boolSV(RETVAL);
		sv_2mortal(ST(0));
	}
	XSRETURN(1);
}


XS(XS_Client_SetSpellImmunity); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetSpellImmunity)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::SetSpellImmunity(THIS, val)");
	{
		Client *		THIS;
		bool		val = (bool)SvTRUE(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetSpellImmunity(val);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetSpellRecastTimer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetSpellRecastTimer)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::GetSpellRecastTimer(THIS, slot)");
	{
		Client *		THIS;
		int32		RETVAL;
		dXSTARG;
		int16		slot = (int16)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetSpellRecastTimer(slot);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_SetSpellRecastTimer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_SetSpellRecastTimer)
{
	dXSARGS;
	if (items != 3)
		Perl_croak(aTHX_ "Usage: Client::SetSpellRecastTimer(THIS, slot, recastDelay)");
	{
		Client *		THIS;
		int16		slot = (int16)SvUV(ST(1));
		int32		recastDelay = (int32)SvUV(ST(2));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		THIS->SetSpellRecastTimer(slot, recastDelay);
	}
	XSRETURN_EMPTY;
}


XS(XS_Client_GetEXPForLevel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_GetEXPForLevel)
{
	dXSARGS;
	if (items != 2)
		Perl_croak(aTHX_ "Usage: Client::GetEXPForLevel(THIS, level)");
	{
		Client *		THIS;
		uint32		RETVAL;
		dXSTARG;
		int8		level = (int8)SvUV(ST(1));

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		RETVAL = THIS->GetEXPForLevel(level);
		XSprePUSH; PUSHu((UV)RETVAL);
	}
	XSRETURN(1);
}


XS(XS_Client_RemoveOneCharge); /* prototype to pass -Wmissing-prototypes */
XS(XS_Client_RemoveOneCharge)
{
	dXSARGS;
	if (items < 2 || items > 3)
		Perl_croak(aTHX_ "Usage: Client::RemoveOneCharge(THIS, slotid, deleteItemOnLastCharge=false)");
	{
		Client *		THIS;
		uint32		slotid = (uint32)SvUV(ST(1));
		bool		deleteItemOnLastCharge;

		if (sv_derived_from(ST(0), "Client")) {
			IV tmp = SvIV((SV*)SvRV(ST(0)));
			THIS = INT2PTR(Client *,tmp);
		}
		else
			Perl_croak(aTHX_ "THIS is not of type Client");
		if(THIS == NULL)
			Perl_croak(aTHX_ "THIS is NULL, avoiding crash.");

		if (items < 3)
			deleteItemOnLastCharge = false;
		else {
			deleteItemOnLastCharge = (bool)SvTRUE(ST(2));
		}

		THIS->RemoveOneCharge(slotid, deleteItemOnLastCharge);
	}
	XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Client); /* prototype to pass -Wmissing-prototypes */
XS(boot_Client)
{
	dXSARGS;
	char file[256];
	strncpy(file, __FILE__, 256);
	file[255] = 0;
	
	if(items != 1)
		fprintf(stderr, "boot_quest does not take any arguments.");
	char buf[128];

	//add the strcpy stuff to get rid of const warnings....



	XS_VERSION_BOOTCHECK ;

		newXSproto(strcpy(buf, "IsClient"), XS_Client_IsClient, file, "$");
		newXSproto(strcpy(buf, "Disconnect"), XS_Client_Disconnect, file, "$");
		newXSproto(strcpy(buf, "Message"), XS_Client_Message, file, "$$$;@");
		newXSproto(strcpy(buf, "AddToCursorBag"), XS_Client_AddToCursorBag, file, "$$$;$");
		newXSproto(strcpy(buf, "GetIP"), XS_Client_GetIP, file, "$");
		newXSproto(strcpy(buf, "GetPort"), XS_Client_GetPort, file, "$");
		newXSproto(strcpy(buf, "Save"), XS_Client_Save, file, "$");
		newXSproto(strcpy(buf, "Connected"), XS_Client_Connected, file, "$");
		newXSproto(strcpy(buf, "Kick"), XS_Client_Kick, file, "$");
		newXSproto(strcpy(buf, "GetAnon"), XS_Client_GetAnon, file, "$");
		newXSproto(strcpy(buf, "Attack"), XS_Client_Attack, file, "$$;$$$");
		newXSproto(strcpy(buf, "Heal"), XS_Client_Heal, file, "$");
		newXSproto(strcpy(buf, "Damage"), XS_Client_Damage, file, "$$$$;$");
		newXSproto(strcpy(buf, "Death"), XS_Client_Death, file, "$$$;$$");
		newXSproto(strcpy(buf, "MakeCorpse"), XS_Client_MakeCorpse, file, "$");
		newXSproto(strcpy(buf, "SetMana"), XS_Client_SetMana, file, "$$");
		newXSproto(strcpy(buf, "Duck"), XS_Client_Duck, file, "$;$");
		newXSproto(strcpy(buf, "Sit"), XS_Client_Sit, file, "$;$");
		newXSproto(strcpy(buf, "Stand"), XS_Client_Stand, file, "$;$");
		newXSproto(strcpy(buf, "SetMaxHP"), XS_Client_SetMaxHP, file, "$");
		newXSproto(strcpy(buf, "SetGM"), XS_Client_SetGM, file, "$$");
		newXSproto(strcpy(buf, "GetBaseRace"), XS_Client_GetBaseRace, file, "$");
		newXSproto(strcpy(buf, "GetBaseGender"), XS_Client_GetBaseGender, file, "$");
		newXSproto(strcpy(buf, "GetBaseSTR"), XS_Client_GetBaseSTR, file, "$");
		newXSproto(strcpy(buf, "GetBaseSTA"), XS_Client_GetBaseSTA, file, "$");
		newXSproto(strcpy(buf, "GetBaseCHA"), XS_Client_GetBaseCHA, file, "$");
		newXSproto(strcpy(buf, "GetBaseDEX"), XS_Client_GetBaseDEX, file, "$");
		newXSproto(strcpy(buf, "GetBaseINT"), XS_Client_GetBaseINT, file, "$");
		newXSproto(strcpy(buf, "GetBaseAGI"), XS_Client_GetBaseAGI, file, "$");
		newXSproto(strcpy(buf, "GetBaseWIS"), XS_Client_GetBaseWIS, file, "$");
		newXSproto(strcpy(buf, "GetLanguageSkill"), XS_Client_GetLanguageSkill, file, "$$");
		newXSproto(strcpy(buf, "SetLanguageSkill"), XS_Client_SetLanguageSkill, file, "$$$");
		newXSproto(strcpy(buf, "GetSTR"), XS_Client_GetSTR, file, "$");
		newXSproto(strcpy(buf, "GetSTA"), XS_Client_GetSTA, file, "$");
		newXSproto(strcpy(buf, "GetDEX"), XS_Client_GetDEX, file, "$");
		newXSproto(strcpy(buf, "GetAGI"), XS_Client_GetAGI, file, "$");
		newXSproto(strcpy(buf, "GetINT"), XS_Client_GetINT, file, "$");
		newXSproto(strcpy(buf, "GetWIS"), XS_Client_GetWIS, file, "$");
		newXSproto(strcpy(buf, "GetCHA"), XS_Client_GetCHA, file, "$");
		newXSproto(strcpy(buf, "GetEXP"), XS_Client_GetEXP, file, "$");
		newXSproto(strcpy(buf, "GetHP"), XS_Client_GetHP, file, "$");
		newXSproto(strcpy(buf, "GetMaxHP"), XS_Client_GetMaxHP, file, "$");
		newXSproto(strcpy(buf, "GetBaseHP"), XS_Client_GetBaseHP, file, "$");
		newXSproto(strcpy(buf, "CalcMaxHP"), XS_Client_CalcMaxHP, file, "$");
		newXSproto(strcpy(buf, "CalcBaseHP"), XS_Client_CalcBaseHP, file, "$");
		newXSproto(strcpy(buf, "GetTotalLevelExp"), XS_Client_GetTotalLevelExp, file, "$");
		newXSproto(strcpy(buf, "AddEXP"), XS_Client_AddEXP, file, "$$;$");
		newXSproto(strcpy(buf, "SetEXP"), XS_Client_SetEXP, file, "$$");
		newXSproto(strcpy(buf, "SetLevel"), XS_Client_SetLevel, file, "$$;$");
		newXSproto(strcpy(buf, "GoToBind"), XS_Client_GoToBind, file, "$;$");
		newXSproto(strcpy(buf, "SetBindPoint"), XS_Client_SetBindPoint, file, "$");
		newXSproto(strcpy(buf, "MovePC"), XS_Client_MovePC, file, "$$$$$;$$");
		newXSproto(strcpy(buf, "ZonePC"), XS_Client_ZonePC, file, "$$$$$");
		newXSproto(strcpy(buf, "TeleportPC"), XS_Client_TeleportPC, file, "$$$$$;$");
		newXSproto(strcpy(buf, "TranslocatePC"), XS_Client_TranslocatePC, file, "$$$$$");
		newXSproto(strcpy(buf, "SummonItem"), XS_Client_SummonItem, file, "$$;$");
		newXSproto(strcpy(buf, "SummonItemNonBlob"), XS_Client_SummonItemNonBlob, file, "$$;$");
		newXSproto(strcpy(buf, "ChangeSurname"), XS_Client_ChangeSurname, file, "$$");
		newXSproto(strcpy(buf, "SetFactionLevel"), XS_Client_SetFactionLevel, file, "$$$$$$");
		newXSproto(strcpy(buf, "SetFactionLevel2"), XS_Client_SetFactionLevel2, file, "$$$$$$$");
		newXSproto(strcpy(buf, "GetSkill"), XS_Client_GetSkill, file, "$$");
		newXSproto(strcpy(buf, "SetSkill"), XS_Client_SetSkill, file, "$$$");
		newXSproto(strcpy(buf, "CharacterID"), XS_Client_CharacterID, file, "$");
		newXSproto(strcpy(buf, "AccountID"), XS_Client_AccountID, file, "$");
		newXSproto(strcpy(buf, "AccountName"), XS_Client_AccountName, file, "$");
		newXSproto(strcpy(buf, "Admin"), XS_Client_Admin, file, "$");
		newXSproto(strcpy(buf, "UpdateAdmin"), XS_Client_UpdateAdmin, file, "$");
		newXSproto(strcpy(buf, "UpdateWho"), XS_Client_UpdateWho, file, "$;$");
		newXSproto(strcpy(buf, "GMHideMe"), XS_Client_GMHideMe, file, "$;$");
		newXSproto(strcpy(buf, "GuildEQID"), XS_Client_GuildEQID, file, "$");
		newXSproto(strcpy(buf, "GuildDBID"), XS_Client_GuildDBID, file, "$");
		newXSproto(strcpy(buf, "GuildRank"), XS_Client_GuildRank, file, "$");
		newXSproto(strcpy(buf, "SetGuild"), XS_Client_SetGuild, file, "$$$");
		newXSproto(strcpy(buf, "SendManaUpdatePacket"), XS_Client_SendManaUpdatePacket, file, "$");
		newXSproto(strcpy(buf, "GetFace"), XS_Client_GetFace, file, "$");
		newXSproto(strcpy(buf, "GetItemAt"), XS_Client_GetItemAt, file, "$$");
		newXSproto(strcpy(buf, "PutItemInInventory"), XS_Client_PutItemInInventory, file, "$$$$");
		newXSproto(strcpy(buf, "DeleteItemInInventory"), XS_Client_DeleteItemInInventory, file, "$$");
		newXSproto(strcpy(buf, "SendClientMoneyUpdate"), XS_Client_SendClientMoneyUpdate, file, "$$$");
		newXSproto(strcpy(buf, "TakeMoneyFromPP"), XS_Client_TakeMoneyFromPP, file, "$$");
		newXSproto(strcpy(buf, "AddMoneyToPP"), XS_Client_AddMoneyToPP, file, "$$$$$$");
		newXSproto(strcpy(buf, "SendClientQuestCompletedFanfare"), XS_Client_SendClientQuestCompletedFanfare, file, "$");
		newXSproto(strcpy(buf, "SendClientQuestCompletedMoney"), XS_Client_SendClientQuestCompletedMoney, file, "$$$$$$");
		newXSproto(strcpy(buf, "IsGrouped"), XS_Client_IsGrouped, file, "$");
		newXSproto(strcpy(buf, "GroupInvitePending"), XS_Client_GroupInvitePending, file, "$");
		newXSproto(strcpy(buf, "SetGroupInvitePending"), XS_Client_SetGroupInvitePending, file, "$$");
		newXSproto(strcpy(buf, "ProcessChangeLeader"), XS_Client_ProcessChangeLeader, file, "$$");
		newXSproto(strcpy(buf, "RefreshGroup"), XS_Client_RefreshGroup, file, "$$$");
		newXSproto(strcpy(buf, "IsMedding"), XS_Client_IsMedding, file, "$");
		newXSproto(strcpy(buf, "GetDuelTarget"), XS_Client_GetDuelTarget, file, "$");
		newXSproto(strcpy(buf, "IsDueling"), XS_Client_IsDueling, file, "$");
		newXSproto(strcpy(buf, "SetDuelTarget"), XS_Client_SetDuelTarget, file, "$$");
		newXSproto(strcpy(buf, "SetDueling"), XS_Client_SetDueling, file, "$$");
		newXSproto(strcpy(buf, "SetFeigned"), XS_Client_SetFeigned, file, "$$");
		newXSproto(strcpy(buf, "GetFeigned"), XS_Client_GetFeigned, file, "$");
		newXSproto(strcpy(buf, "SetHide"), XS_Client_SetHide, file, "$$");
		newXSproto(strcpy(buf, "GetHide"), XS_Client_GetHide, file, "$");
		newXSproto(strcpy(buf, "SetSneaking"), XS_Client_SetSneaking, file, "$$");
		newXSproto(strcpy(buf, "GetSneaking"), XS_Client_GetSneaking, file, "$");
		newXSproto(strcpy(buf, "GetFactionLevel"), XS_Client_GetFactionLevel, file, "$$$$$$$$");
		newXSproto(strcpy(buf, "GetWornInstrumentType"), XS_Client_GetWornInstrumentType, file, "$");
		newXSproto(strcpy(buf, "GetInstrumentModByType"), XS_Client_GetInstrumentModByType, file, "$$");
		newXSproto(strcpy(buf, "SetInstrumentModByType"), XS_Client_SetInstrumentModByType, file, "$$$");
		newXSproto(strcpy(buf, "ResetAllInstrumentMod"), XS_Client_ResetAllInstrumentMod, file, "$");
		newXSproto(strcpy(buf, "UpdateInstrumentMod"), XS_Client_UpdateInstrumentMod, file, "$");
		newXSproto(strcpy(buf, "HasRequiredInstrument"), XS_Client_HasRequiredInstrument, file, "$$");
		newXSproto(strcpy(buf, "CheckLoreConflict"), XS_Client_CheckLoreConflict, file, "$$");
		newXSproto(strcpy(buf, "SendStationItem"), XS_Client_SendStationItem, file, "$$");
		newXSproto(strcpy(buf, "FindItemInInventory"), XS_Client_FindItemInInventory, file, "$$");
		newXSproto(strcpy(buf, "FindItemTypeInInventory"), XS_Client_FindItemTypeInInventory, file, "$$");
		newXSproto(strcpy(buf, "CreateZoneLineNode"), XS_Client_CreateZoneLineNode, file, "$$$$");
		newXSproto(strcpy(buf, "ScanForZoneLines"), XS_Client_ScanForZoneLines, file, "$");
		newXSproto(strcpy(buf, "FearMovement"), XS_Client_FearMovement, file, "$$$$");
		newXSproto(strcpy(buf, "GetAccountName"), XS_Client_GetAccountName, file, "$");
		newXSproto(strcpy(buf, "GetAccountID"), XS_Client_GetAccountID, file, "$");
		newXSproto(strcpy(buf, "IsStunned"), XS_Client_IsStunned, file, "$");
		newXSproto(strcpy(buf, "GetDebugMe"), XS_Client_GetDebugMe, file, "$");
		newXSproto(strcpy(buf, "SetDebugMe"), XS_Client_SetDebugMe, file, "$$");
		newXSproto(strcpy(buf, "GetMyEyeOfZommID"), XS_Client_GetMyEyeOfZommID, file, "$");
		newXSproto(strcpy(buf, "SetMyEyeOfZomm"), XS_Client_SetMyEyeOfZomm, file, "$$");
		newXSproto(strcpy(buf, "FeignDeath"), XS_Client_FeignDeath, file, "$$");
		newXSproto(strcpy(buf, "GetDeathSave"), XS_Client_GetDeathSave, file, "$");
		newXSproto(strcpy(buf, "SetDeathSave"), XS_Client_SetDeathSave, file, "$$");
		newXSproto(strcpy(buf, "GetFeared"), XS_Client_GetFeared, file, "$");
		newXSproto(strcpy(buf, "SetFeared"), XS_Client_SetFeared, file, "$$");
		newXSproto(strcpy(buf, "GetFearDestination"), XS_Client_GetFearDestination, file, "$$$$");
		newXSproto(strcpy(buf, "GetCharmDestination"), XS_Client_GetCharmDestination, file, "$$$");
		newXSproto(strcpy(buf, "UpdateCharmPosition"), XS_Client_UpdateCharmPosition, file, "$$$$");
		newXSproto(strcpy(buf, "fdistance"), XS_Client_fdistance, file, "$$$$$");
		newXSproto(strcpy(buf, "square"), XS_Client_square, file, "$$");
		newXSproto(strcpy(buf, "SetCharmed"), XS_Client_SetCharmed, file, "$$");
		newXSproto(strcpy(buf, "IsCharmed"), XS_Client_IsCharmed, file, "$");
		newXSproto(strcpy(buf, "SetBerserk"), XS_Client_SetBerserk, file, "$$");
		newXSproto(strcpy(buf, "IsBerserk"), XS_Client_IsBerserk, file, "$");
		newXSproto(strcpy(buf, "CanFish"), XS_Client_CanFish, file, "$");
		newXSproto(strcpy(buf, "GoFish"), XS_Client_GoFish, file, "$");
		newXSproto(strcpy(buf, "SendCharmPermissions"), XS_Client_SendCharmPermissions, file, "$");
		newXSproto(strcpy(buf, "IsInWater"), XS_Client_IsInWater, file, "$");
		newXSproto(strcpy(buf, "IsInLava"), XS_Client_IsInLava, file, "$");
		newXSproto(strcpy(buf, "DoInstillDoubt"), XS_Client_DoInstillDoubt, file, "$");
		newXSproto(strcpy(buf, "BindWound"), XS_Client_BindWound, file, "$$$");
		newXSproto(strcpy(buf, "SetIsZoning"), XS_Client_SetIsZoning, file, "$$");
		newXSproto(strcpy(buf, "SetZoningX"), XS_Client_SetZoningX, file, "$$");
		newXSproto(strcpy(buf, "SetZoningY"), XS_Client_SetZoningY, file, "$$");
		newXSproto(strcpy(buf, "SetZoningZ"), XS_Client_SetZoningZ, file, "$$");
		newXSproto(strcpy(buf, "SetZoningHeading"), XS_Client_SetZoningHeading, file, "$$");
		newXSproto(strcpy(buf, "SetUsingSoftCodedZoneLine"), XS_Client_SetUsingSoftCodedZoneLine, file, "$$");
		newXSproto(strcpy(buf, "SetTempHeading"), XS_Client_SetTempHeading, file, "$$");
		newXSproto(strcpy(buf, "GetVoiceGrafting"), XS_Client_GetVoiceGrafting, file, "$");
		newXSproto(strcpy(buf, "SetVoiceGrafting"), XS_Client_SetVoiceGrafting, file, "$$");
		newXSproto(strcpy(buf, "SetPendingRezExp"), XS_Client_SetPendingRezExp, file, "$$");
		newXSproto(strcpy(buf, "GetPendingRezExp"), XS_Client_GetPendingRezExp, file, "$");
		newXSproto(strcpy(buf, "SetPendingRez"), XS_Client_SetPendingRez, file, "$$");
		newXSproto(strcpy(buf, "GetPendingRez"), XS_Client_GetPendingRez, file, "$");
		newXSproto(strcpy(buf, "SetPendingCorpseID"), XS_Client_SetPendingCorpseID, file, "$$");
		newXSproto(strcpy(buf, "GetPendingCorpseID"), XS_Client_GetPendingCorpseID, file, "$");
		newXSproto(strcpy(buf, "SetPendingRezX"), XS_Client_SetPendingRezX, file, "$$");
		newXSproto(strcpy(buf, "GetPendingRezX"), XS_Client_GetPendingRezX, file, "$");
		newXSproto(strcpy(buf, "SetPendingRezY"), XS_Client_SetPendingRezY, file, "$$");
		newXSproto(strcpy(buf, "GetPendingRezY"), XS_Client_GetPendingRezY, file, "$");
		newXSproto(strcpy(buf, "SetPendingRezZ"), XS_Client_SetPendingRezZ, file, "$$");
		newXSproto(strcpy(buf, "GetPendingRezZ"), XS_Client_GetPendingRezZ, file, "$");
		newXSproto(strcpy(buf, "SetPendingRezZone"), XS_Client_SetPendingRezZone, file, "$$");
		newXSproto(strcpy(buf, "GetPendingRezZone"), XS_Client_GetPendingRezZone, file, "$");
		newXSproto(strcpy(buf, "SetPendingSpellID"), XS_Client_SetPendingSpellID, file, "$$");
		newXSproto(strcpy(buf, "GetPendingSpellID"), XS_Client_GetPendingSpellID, file, "$");
		newXSproto(strcpy(buf, "StartPendingRezTimer"), XS_Client_StartPendingRezTimer, file, "$");
		newXSproto(strcpy(buf, "StopPendingRezTimer"), XS_Client_StopPendingRezTimer, file, "$");
		newXSproto(strcpy(buf, "GetRelativeCoordToBoat"), XS_Client_GetRelativeCoordToBoat, file, "$$$$$$");
		newXSproto(strcpy(buf, "IsAlive"), XS_Client_IsAlive, file, "$");
		newXSproto(strcpy(buf, "GetSpellImmunity"), XS_Client_GetSpellImmunity, file, "$");
		newXSproto(strcpy(buf, "SetSpellImmunity"), XS_Client_SetSpellImmunity, file, "$$");
		newXSproto(strcpy(buf, "GetSpellRecastTimer"), XS_Client_GetSpellRecastTimer, file, "$$");
		newXSproto(strcpy(buf, "SetSpellRecastTimer"), XS_Client_SetSpellRecastTimer, file, "$$$");
		newXSproto(strcpy(buf, "GetEXPForLevel"), XS_Client_GetEXPForLevel, file, "$$");
		newXSproto(strcpy(buf, "RemoveOneCharge"), XS_Client_RemoveOneCharge, file, "$$;$");
	XSRETURN_YES;
}

#endif //EMBPERL_XS_CLASSES

